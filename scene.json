{
	"camera" : 
	{
		"center" : "0.00000 0.00000 0.00000",
		"eye" : "0.00000 0.00000 1.00000",
		"up" : "0.00000 1.00000 0.00000"
	},
	"general" : 
	{
		"ambientcolor" : "0.30000 0.30000 0.30000",
		"bloom" : false,
		"bloomhdrfeather" : 0.10000000149011612,
		"bloomhdrscatter" : 1.6189999580383301,
		"bloomhdrstrength" : 2.0,
		"bloomhdrthreshold" : 1.0,
		"bloomstrength" : 2.0,
		"bloomthreshold" : 0.64999997615814209,
		"camerafade" : true,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.10000000149011612,
		"cameraparallaxdelay" : 2.75,
		"cameraparallaxmouseinfluence" : 0.10000000149011612,
		"camerapreview" : true,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.00000 0.00000 0.00000",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 50.0,
		"hdr" : false,
		"nearz" : 0.0099999997764825821,
		"orthogonalprojection" : 
		{
			"height" : 2160,
			"width" : 3840
		},
		"skylightcolor" : "0.30000 0.30000 0.30000",
		"zoom" : 
		{
			"script" : "'use strict';\n\n// // Zoom in when mouse is over the eyes\n\n// const maxSpeed = 0.4;\n// const accel = 0.2;\n// const zoomFactor = 1.05;\n\n// /**\n//  * @param {Number} value - for property 'zoom'\n//  * @return {Number} - update current property value\n//  */\n// export function update(value) {\n// \tlet mousePos = input.cursorScreenPosition.divide(engine.screenResolution);\n// \tlet target1 = new Vec2(0.43, 0.44).subtract(mousePos);\n// \tlet target2 = new Vec2(0.57, 0.44).subtract(mousePos);\n// \ttarget1 = Math.abs(target1.x) + Math.abs(target1.y);\n// \ttarget2 = Math.abs(target2.x) + Math.abs(target2.y);\n// \t// console.log(`${target1} - ${target2}`);\n// \tlet target = Math.min(target1, target2);\n// \ttarget = Math.max(zoomFactor - target, 1.0);\n\n// \tlet speed = (target-value) * accel;\n// \tspeed = Math.max(Math.min(speed, maxSpeed), -maxSpeed);\n\n// \tvalue = value + speed * engine.frametime;\n// \treturn value;\n// }\n",
			"value" : 1.0
		}
	},
	"objects" : 
	[
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 7,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGHelpers (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addColor({\n\t\tname: 'debugText_FlashColor',\n\t\tlabel: 'Debug Flash Color',\n\t\tvalue: new Vec3(0.5, 1.0, 1.0)\n\t})\n\t.finish();\n\nlet bEnableDebugText = true;\nlet debugText_Layers = [];\n// let debugText_FlashColor = new Vec3(0.5, 1.0, 1.0);\nlet debugText_Color = new Vec3(1.0, 1.0, 1.0);\nlet debugText_ShowBackground = true;\nlet debugText_BackgroundColor = new Vec3(0.1, 0.1, 0.1);\nlet debugText_Size = 5;\nlet debugText_Alpha = 0.75;\nlet debugText_FlashScale = 1.01;\n/** How many milliseconds to fade from the flash color to the normal color when the text is updated. */\nlet debugText_FlashTime = 250;\n/** How many milliseconds to display the text before starting to fade out. */\nlet debugText_StickTime = 500;\n/** How many milliseconds to fade out the debug text before removing it. */\nlet debugText_FadeTime = 1500;\n\n\nlet _canvasToScreen = 1.0;\n\n\nexport function update() {\n\tlet currentTime = new Date().getTime();\n\t\n\tdebugText_Layers.forEach(\n\t\tfunction(textLayer, index, array) {\n\t\t\tif (currentTime > textLayer.lastUpdated + (debugText_StickTime + debugText_FadeTime)) {\n\t\t\t\ttextLayer.alpha = 0;\n\t\t\t\tthisScene.destroyLayer(textLayer);\n\t\t\t\tarray.splice(index, 1);\n\t\t\t}\n\t\t\telse if (currentTime > textLayer.lastUpdated + debugText_StickTime) {\n\t\t\t\ttextLayer.color = debugText_Color;\n\t\t\t\tlet fadeLerp = (currentTime - (textLayer.lastUpdated + debugText_StickTime)) / debugText_FadeTime;\n\t\t\t\ttextLayer.alpha = OMGHelpers.lerp(debugText_Alpha, 0, fadeLerp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet flashLerp = OMGHelpers.clamp((currentTime - textLayer.lastChanged) / debugText_FlashTime);\n\t\t\t\ttextLayer.color = OMGHelpers.lerp(scriptProperties.debugText_FlashColor, debugText_Color, flashLerp);\n\t\t\t\ttextLayer.scale = new Vec3(OMGHelpers.lerp(debugText_FlashScale * _canvasToScreen, 1 * _canvasToScreen, flashLerp));\n\t\t\t\ttextLayer.alpha = debugText_Alpha;\n\t\t\t}\n\n\t\t\tif (engine.canvasSize.x !== 0) {\n\t\t\t\tlet cornerY = engine.canvasSize.y;\n\t\t\t\tlet cornerX = 0;\n\t\t\t\tlet screenAspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\t\t\t\tlet canvasAspectRatio = engine.canvasSize.x / engine.canvasSize.y;\n\t\t\t\tif (screenAspectRatio > canvasAspectRatio) {\n\t\t\t\t\tcornerY = engine.screenResolution.y * engine.canvasSize.x / engine.screenResolution.x;\n\t\t\t\t\tcornerY += (engine.canvasSize.y - cornerY) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcornerX = engine.screenResolution.x * engine.canvasSize.y / engine.screenResolution.y;\n\t\t\t\t\tcornerX = (engine.canvasSize.x - cornerX) / 2;\n\t\t\t\t}\n\t\t\t\ttextLayer.origin = new Vec3(cornerX, cornerY - index * (debugText_Size * 4.9 - 0.5) * _canvasToScreen, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet aspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\t\t\t\tlet ct = thisScene.getCameraTransforms();\n\t\t\t\tlet forward = ct.center.subtract(ct.eye).normalize();\n\t\t\t\tlet up = ct.up;\n\t\t\t\tlet right = forward.cross(up);\n\t\t\t\tlet pos = ct.eye.add(forward).add(up.multiply(0.45)).add(right.multiply(-0.45 * aspectRatio));\n\t\t\t\tpos.y -= index * (debugText_Size * .002);\n\t\t\t\ttextLayer.origin = new Vec3(pos.x, pos.y, pos.z);\n\t\t\t\ttextLayer.scale = new Vec3(0.0005);\n\t\t\t}\n\t\t\ttextLayer.pointsize = debugText_Size;\n\n\t\t\ttextLayer.visible = bEnableDebugText;\n\t\t}\n\t);\n}\n\n\nexport function init() {\n\t_canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n}\n\n\nexport function resizeScreen() {\n\t_canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n}\n\n\n\n\nclass OMGHelpers {\n\t/** Prints all key/value pairs present on the object to the console. */\n\tstatic printObjectValues(obj){\n\t\tif (typeof(obj) !== 'object' || obj === null)\n\t\t\treturn;\n\n\t\tfor (const key of Object.keys(obj))\n\t\t\tconsole.log(key + \" - \" + obj[key]);\n\t}\n\n\t/** Attempts to add two values together. */\n\tstatic add(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 + v2;\n\t\telse if (v1.add)\n\t\t\treturn v1.add(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to subtract the second value from the first value. */\n\tstatic subtract(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 - v2;\n\t\telse if (v1.subtract)\n\t\t\treturn v1.subtract(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to multiply two values together. */\n\tstatic multiply(v1, v2) {\n\t\tif (v2 === undefined)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to divide the first value by the second value. */\n\tstatic divide(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/**\n\t * True if the two parameters are the same type and contain equal values, otherwise false\n\t * @param [epsilon] {number} The minimum difference allowed between number values before they are considered non-equal (helps avoid some floating-point issues)\n\t * @return {boolean}\n\t */\n\tstatic equal(v1, v2, epsilon = 0.0001){\n\t\tif (v1 instanceof Vec3) {\n\t\t\tif (v2 instanceof Vec3)\n\t\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v1.z) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tif (v2 instanceof Vec2)\n\t\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse switch (typeof v1) {\n\t\tcase \"number\":\n\t\t\tif (typeof v2 === \"number\")\n\t\t\t\treturn (Math.abs(v1 - v2) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (v1 === v2);\n\t\t}\n\t}\n\n\t/** Restricts a value to remain between two boundary values. \n\t * @param {number} val - The value to be restricted.\n\t * @param {number} min - The lower bound.\n\t * @param {number} max - The upper bound.\n\t*/\n\tstatic clamp(val, min = 0, max = 1) {\n\t\tif (typeof(val) === \"number\")\n\t\t\treturn Math.min(max, Math.max(min, val));\n\t\telse if (val instanceof Vec2) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (val instanceof Vec3) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\tlet z = Math.min(max.z, Math.max(min.z, val.z));\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (val instanceof Vec4) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\tlet z = Math.min(max.z, Math.max(min.z, val.z));\n\t\t\tlet w = Math.min(max.w, Math.max(min.w, val.w));\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t}\n\n\t/** Interpolate linearly from the first value to the second based on the third (0 to 1) */\n\tstatic lerp(v1, v2, percent) {\n\t\tif (typeof(v1) === \"number\")\n\t\t\treturn v1 + (v2 - v1) * percent;\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (v1 instanceof Vec3) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (v1 instanceof Vec4) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\tlet w = v1.w + (v2.w - v1.w) * percent;\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Prints a stack trace to the console. */\n\tstatic stackTrace() {\n\t\treturn console.log(new Error().stack);\n\t}\n\t\n\t/** Creates or updates a text layer in the corner of the screen. \n\t * @param {string} name - The name of the text layer to create or update.\n\t * @param {string} text - The text that the layer should display.\n\t*/\n\tstatic debugText(name, text) {\n\t\tif (bEnableDebugText && name !== undefined && text !== undefined) {\n\t\t\tlet layer = thisScene.getLayer(name.toString());\n\t\t\tif (layer) {\n\t\t\t\tif (layer.text != text) {\n\t\t\t\t\tlayer.text = text;\n\t\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\t\tlayer.color = scriptProperties.debugText_FlashColor;\n\t\t\t\t\tlayer.scale = new Vec3(debugText_FlashScale * _canvasToScreen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlayer.lastUpdated = new Date().getTime();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet layerSettings = new Object();\n\t\t\t\tif (engine.canvasSize.x !== 0) {\n\t\t\t\t\tlayerSettings.origin = \"0, \" + (engine.canvasSize.y - debugText_Layers.length * (debugText_Size * 3 + 10)) + \", 0\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet ct = thisScene.getCameraTransforms();\n\t\t\t\t\tlet forward = ct.center.subtract(ct.eye).normalize();\n\t\t\t\t\tlet up = ct.up;\n\t\t\t\t\tlet right = forward.cross(up);\n\t\t\t\t\tlet pos = new Vec3(0, .5, 0);//ct.eye.add(forward);//.add(right);\n\t\t\t\t\tlayerSettings.origin = `${pos.x}, ${pos.y}, ${pos.z}`;\n\t\t\t\t}\n\t\t\t\tlayerSettings.name = name.toString();\n\t\t\t\tlayerSettings.text = text;\n\t\t\t\tlayerSettings.pointsize = debugText_Size;\n\t\t\t\tlayerSettings.font = \"systemfont_consolas\";\n\n\t\t\t\tlayerSettings.verticalalign = \"top\";\n\t\t\t\tlayerSettings.horizontalalign = \"left\";\n\t\t\t\tlayerSettings.color = scriptProperties.debugText_FlashColor.x + \", \" + scriptProperties.debugText_FlashColor.y + \", \" + scriptProperties.debugText_FlashColor.z;\n\t\t\t\tlayerSettings.opaquebackground = debugText_ShowBackground;\n\t\t\t\tlayerSettings.backgroundcolor = debugText_BackgroundColor;\n\t\t\t\tlayerSettings.padding = 0;\n\t\t\t\tlayerSettings.alpha = debugText_Alpha;\n\t\t\t\tlayer = thisScene.createLayer(layerSettings);\n\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\tdebugText_Layers.push(layer);\n\t\t\t}\n\t\t}\n\t}\n}\n\nshared.OMGHelpers = OMGHelpers;",
				"scriptproperties" : 
				{
					"debugText_FlashColor" : "0.49804 1.00000 1.00000"
				},
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 9,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGMatrix (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n// matrix functions referenced from https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js\n\nconst deg2rad = Math.PI / 180;\nconst rad2deg = 180 / Math.PI;\n\nfunction clamp(x, min, max){ return Math.max(Math.min(x, max), min) }\n\nclass Mat4 {\n\tconstructor(b){\n\t\tif (b instanceof Mat4){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = b.elements[i].slice();\n\t\t\t}\n\t\t}\n\t\telse if (arguments.length === 16){\n\t\t\tthis.elements = new Array(4);\n\t\t\tfor(let i = 0; i < 4; i++){\n\t\t\t\tthis.elements[i] = new Array(4);\n\t\t\t\tfor(let j = 0; j < 4; j++){\n\t\t\t\t\tthis.elements[i][j] = arguments[i*4 + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tthis.elements = [\n\t\t\t\t[1, 0, 0, 0],\n\t\t\t\t[0, 1, 0, 0],\n\t\t\t\t[0, 0, 1, 0],\n\t\t\t\t[0, 0, 0, 1]\n\t\t\t];\n\t\t}\n\t}\n\n\n\tprintElements(){\n\t\tfor(let x = 0; x < 4; x++){\n\t\t\tlet line = \"\";\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tline += this.elements[x][y].toString() + \" \";\n\t\t\t}\n\t\t\tconsole.log(line);\n\t\t}\n\t}\n\n\n\tmultiply(right){\n\t\tlet a = this.elements;\n\t\tlet b = right.elements;\n\t\tlet r = new Mat4();\n\n\t\tfor (let x = 0; x < 4; x++){\n\t\t\tfor(let y = 0; y < 4; y++){\n\t\t\t\tr.elements[x][y] = a[x][0] * b[0][y] + a[x][1] * b[1][y] + a[x][2] * b[2][y] + a[x][3] * b[3][y];\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\n\tstatic fromAxisAngle(axis, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\tlet t = 1 - cos;\n\t\tlet x = axis.x, y = axis.y, z = axis.z;\n\t\tlet tx = t*x, ty = t*y;\n\n\t\treturn new Mat4(\n\t\t\ttx * x + cos,      tx * y - sin * z,  tx * z + sin * y,  0,\n\t\t\ttx * y + sin * z,  ty * y + cos,      ty * z - sin * x,  0,\n\t\t\ttx * z - sin * y,  ty * z + sin * x,  t * z * z + cos,   0,\n\t\t\t0,                 0,                 0,                 1\n\t\t);\n\t}\n\n\n\tstatic fromPosition(pos){\n\t\treturn new Mat4(\n\t\t\t1, 0, 0, pos.x,\n\t\t\t0, 1, 0, pos.y,\n\t\t\t0, 0, 1, pos.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\t}\n\n\n\ttoPosition(){\n\t\tlet m = this.elements;\n\t\treturn new Vec3(m[0][3], m[1][3], m[2][3]);\n\t}\n\n\n\tstatic fromEuler(angles, order){\n\t\tlet r = new Mat4();\n\t\tlet e = angles.multiply(deg2rad);\n\t\tlet sx = Math.sin(e.x), sy = Math.sin(e.y), sz = Math.sin(e.z);\n\t\tlet cx = Math.cos(e.x), cy = Math.cos(e.y), cz = Math.cos(e.z);\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = -cy * sz;\n\t\t\t\tr.elements[0][2] = sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz + sx * cz * sy;\n\t\t\t\tr.elements[1][1] = cx * cz - sx * sz * sy;\n\t\t\t\tr.elements[1][2] = -sx * cy;\n\n\t\t\t\tr.elements[2][0] = sx * sz - cx * cz * sy;\n\t\t\t\tr.elements[2][1] = sx * cz + cx * sz * sy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YXZ\":\n\t\t\t\tr.elements[0][0] = cy * cz + sy * sz * sx;\n\t\t\t\tr.elements[0][1] = sy * cz * sx - cy * sz;\n\t\t\t\tr.elements[0][2] = cx * sy;\n\n\t\t\t\tr.elements[1][0] = cx * sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx;\n\n\t\t\t\tr.elements[2][0] = cy * sz * sx - sy * cz;\n\t\t\t\tr.elements[2][1] = sy * sz + cy * cz * sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZXY\":\n\t\t\t\tr.elements[0][0] = cy * cz - sy * sz * sx\n\t\t\t\tr.elements[0][1] = -cx * sz;\n\t\t\t\tr.elements[0][2] = sy * cz + cy * sz * sx;\n\n\t\t\t\tr.elements[1][0] = cy * sz + sy * cz * sx;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = sy * sz - cy * cz * sx;\n\n\t\t\t\tr.elements[2][0] = -cx * sy;\n\t\t\t\tr.elements[2][1] = sx;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"ZYX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * cz * sy - cx * sz;\n\t\t\t\tr.elements[0][2] = cx * cz * sy + sx * sz;\n\n\t\t\t\tr.elements[1][0] = cy * sz;\n\t\t\t\tr.elements[1][1] = sx * sz * sy + cx * cz;\n\t\t\t\tr.elements[1][2] = cx * sz * sy - sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy;\n\t\t\t\tr.elements[2][1] = sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy;\n\t\t\t\tbreak;\n\n\t\t\tcase \"YZX\":\n\t\t\t\tr.elements[0][0] = cy * cz;\n\t\t\t\tr.elements[0][1] = sx * sy - cx * cy * sz;\n\t\t\t\tr.elements[0][2] = sx * cy * sz + cx * sy;\n\n\t\t\t\tr.elements[1][0] = sz;\n\t\t\t\tr.elements[1][1] = cx * cz;\n\t\t\t\tr.elements[1][2] = -sx * cz;\n\n\t\t\t\tr.elements[2][0] = -sy * cz;\n\t\t\t\tr.elements[2][1] = cx * sy * sz + sx * cy;\n\t\t\t\tr.elements[2][2] = cx * cy - sx * sy * sz;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// right colur.elementsn\n\t\tr.elements[0][3] = 0;\n\t\tr.elements[1][3] = 0;\n\t\tr.elements[2][3] = 0;\n\t\t\n\t\t// bottor.elements row\n\t\tr.elements[3][0] = 0;\n\t\tr.elements[3][1] = 0;\n\t\tr.elements[3][2] = 0;\n\t\tr.elements[3][3] = 1;\n\n\t\treturn r;\n\t}\n\n\n\ttoEuler(order){\n\t\tlet m = this.elements;\n\t\tlet x,y,z;\n\n\t\tlet o = order;\n\t\tif (typeof(o) !== \"string\")\n\t\t\to = \"XYZ\";\n\n\t\tswitch (o.toUpperCase()){\n\t\t\tcase \"XYZ\":\n\t\t\tdefault:\n\t\t\t\ty = Math.asin(clamp(m[0][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][2] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YXZ\":\n\t\t\t\tx = Math.asin(-clamp(m[1][2], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][2] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t\tz = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZXY\":\n\t\t\t\tx = Math.asin(clamp(m[2][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][1] < 0.999999)){\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[2][2]);\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ZYX\":\n\t\t\t\ty = Math.asin(-clamp(m[2][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[2][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[2][2]);\n\t\t\t\t\tz = Math.atan2(m[1][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\tz = Math.atan2(-m[0][1], m[1][1]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"YZX\":\n\t\t\t\tz = Math.asin(clamp(m[1][0], -1, 1));\n\n\t\t\t\tif (Math.abs(m[1][0] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[1][1]);\n\t\t\t\t\ty = Math.atan2(-m[2][0], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = Math.atan2(m[0][2], m[2][2]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"XZY\":\n\t\t\t\tz = Math.asin(-clamp(m[0][1], -1, 1));\n\n\t\t\t\tif (Math.abs(m[0][1] < 0.999999)){\n\t\t\t\t\tx = Math.atan2(m[2][1], m[1][1]);\n\t\t\t\t\ty = Math.atan2(m[0][2], m[0][0]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tx = Math.atan2(-m[1][2], m[2][2]);\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tlet euler = new Vec3(x, y, z);\n\t\teuler = euler.multiply(rad2deg);\n\t\treturn euler;\n\t}\n\n\tstatic fromScale(s) {\n\t\treturn new Mat4(\n\t\t\ts.x, 0,   0,   0,\n\t\t\t0,   s.y, 0,   0,\n\t\t\t0,   0,   s.z, 0,\n\t\t\t0,   0,   0,   1\n\t\t);\n\t}\n\n\ttoScale() {\n\t\tlet m = this.elements;\n\t\treturn new Vec3(\n\t\t\tMath.sqrt(m[0][0]*m[0][0] + m[0][1]*m[0][1] + m[0][2]*m[0][2]),\n\t\t\tMath.sqrt(m[1][0]*m[1][0] + m[1][1]*m[1][1] + m[1][2]*m[1][2]),\n\t\t\tMath.sqrt(m[2][0]*m[2][0] + m[2][1]*m[2][1] + m[2][2]*m[2][2])\n\t\t);\n\t}\n};\n\nshared.Mat4 = Mat4;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 10,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "OMGVector (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nclass OMGVector {\n\t/**\n\t * @param {Vec3} vector\n\t * @param {Number} angle\n\t * Rotates the vector in radians around the X axis\n\t */\n\tstatic rotX(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x, \n\t\t\tvector.y * cos - vector.z * sin,\n\t\t\tvector.y * sin + vector.z * cos)\n\t};\n\n\tstatic rotY(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos + vector.z * sin,\n\t\t\tvector.y, \n\t\t\t-vector.x * sin + vector.z * cos)\n\t};\n\n\tstatic rotZ(vector, angle){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\tvector.x * cos - vector.y * sin,\n\t\t\tvector.x * sin + vector.y * cos,\n\t\t\tvector.z)\n\t};\n\n\tstatic rotAxis(vec, angle, axis){\n\t\tlet cos = Math.cos(angle);\n\t\tlet sin = Math.sin(angle);\n\t\treturn new Vec3(\n\t\t\t(cos + (1 - cos) * axis.x * axis.x) * vec.x +\n\t\t\t((1 - cos) * axis.x * axis.y - axis.z * sin) * vec.y +\n\t\t\t((1 - cos) * axis.x * axis.z + axis.y * sin) * vec.z,\n\n\t\t\t((1 - cos) * axis.x * axis.y + axis.z * sin) * vec.x +\n\t\t\t(cos + (1 - cos) * axis.y * axis.y) * vec.y +\n\t\t\t((1 - cos) * axis.y * axis.z - axis.x * sin) * vec.z,\n\n\t\t\t((1 - cos) * axis.x * axis.z - axis.y * sin) * vec.x +\n\t\t\t((1 - cos) * axis.y * axis.z + axis.x * sin) * vec.y +\n\t\t\t(cos + (1 - cos) * axis.z * axis.z) * vec.z\n\t\t);\n\t};\n\n\tstatic rotVec(vector, angles){\n\t\tlet r = rotX(vector, angles.x);\n\t\tr = rotY(r, angles.y);\n\t\treturn r = rotZ(r, angles.z);\n\t};\n\n\tstatic unrotVec(vector, angles){\n\t\tlet r = rotZ(vector, -angles.x);\n\t\tr = rotY(r, -angles.y);\n\t\treturn r = rotX(r, -angles.z);\n\t};\n\n\tstatic forwardY(angles){\n\t\treturn rotVec(new Vec3(0., 1., 0.), angles);\n\t};\n\n\tstatic forwardZ(angles){\n\t\treturn rotVec(new Vec3(0., 0., 1.), angles);\n\t};\n\n\tstatic forwardX(angles){\n\t\treturn rotVec(new Vec3(1., 0., 0.), angles);\n\t};\n\n\tstatic interpAngle(angle1, angle2, percent){\n\t\tlet a1 = [angle1.x % 360, angle1.y % 360, angle1.z % 360];\n\t\tlet a2 = [angle2.x % 360, angle2.y % 360, angle2.z % 360];\n\t\tlet diff = [];\n\t\tfor (let i = 0; i < 3; i++){\n\t\t\tif (a1[i] < 0)\n\t\t\t\ta1[i] += 360;\n\t\t\tif (a2[i] < 0)\n\t\t\t\ta2[i] += 360;\n\t\t\tdiff[i] = a2[i] - a1[i];\n\t\t\tif (diff[i] > 180)\n\t\t\t\tdiff[i] -= 360;\n\t\t\telse if (diff[i] < -180)\n\t\t\t\tdiff[i] += 360;\n\t\t}\n\t\treturn new Vec3(a1[0] + diff[0] * percent, a1[1] + diff[1] * percent, a1[2] + diff[2] * percent);\n\t};\n\n\tstatic interpPosition(pos1, pos2, percent){\n\t\treturn lerp(pos1, pos2, percent);\n\t}\n\n\t/**\n\t * Interpolates linearly between v1 and v2 based on percent (0 to 1).\n\t * @param {Vec3} v1 First vector\n\t * @param {Vec3} v2 Second vector\n\t * @param {Number} percent interpolation value between 0 and 1\n\t */\n\tstatic lerp(v1, v2, percent){\n\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\treturn new Vec3(x, y, z);\n\t};\n\t\n\n\tstatic magnitude(vec){\n\t\treturn Math.sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n\t}\n\n\tstatic normalize(vec){\n\t\treturn vec.multiply(1 / OMGVector.magnitude(vec));\n\t};\n\n\t/**\n\t * True if the two vectors contain equal x, y, and z values, otherwise false\n\t * @param [epsilon] {number} The minimum difference allowed between vector values before they are considered non-equal (helps avoid some floating-point issues)\n\t * @return {boolean}\n\t */\n\tstatic equal(v1, v2, epsilon = 0.0001){\n\t\tif (epsilon)\n\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v1.z) < epsilon);\n\t\telse\n\t\t\treturn (v1.x === v2.x && v1.y === v2.y && v1.z === v1.z);\n\t}\n}\n\nshared.OMGVector = OMGVector;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 11,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "LayerParenting (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\nconst Mat4 = shared.Mat4;\nconst OMGVector = shared.OMGVector;\n\nexport function init() { \n\t// Create a simple dummy layer for the root node.\n\t_rootNode.layerID = thisScene.getLayerIndex(thisScene.createLayer({\n\t\tname: \"root\",\n\t\tsound: [],\n\t\t}));\n}\nexport function update() { LayerParenting.update(); }\n\n\n/**\n * Bitwise flags representing the properties of the parent layer which should be inherited.\n * @enum {number} \n */\nconst PARENTFLAG = {\n\tPOSITION   : 1 << 0,\n\tROTATION   : 1 << 1,\n\tSCALE      : 1 << 2,\n\tVISIBILITY : 1 << 3,\n\tALL        : ~0\n}\n\n\n/** \n * Contains references to every non-root node, indexed by layer ID.\n * @type Object.<number, LayerTreeNode>\n */\nlet _treeDirectory = {};\n\n/** \n * Root node for the scene. Any children of this node effectively have no parent.\n * @type {LayerTreeNode}\n */\nlet _rootNode = undefined; // gets defined after LayerTreeNode's definition.\n\n/** \n * Node in the layer tree which represents a layer and its relationship to any child layers. \n */\nclass LayerTreeNode {\n/** \n * @typedef LayerTreeNodeParams {Object} \n * @property layerID {number} - The ID of the layer represented by this node.\n * @property [parentNode] {LayerTreeNode} - This node's parent.\n * @property [parentFlags] {PARENTFLAG} - An optional set of flags enabling or disabling parenting of various layer attributes.\n * @property [position] {Vec3} - The layer's translational offset from the parent.\n * @property [rotation] {Vec3} - The layer's local rotation in degrees.\n * @property [scale] {Vec3} - The layer's scale.\n */\n\t/** \n\t * @param params {LayerTreeNodeParams} - Object which enables parameters to be set by name rather than by sequence. \n\t */\n\tconstructor(params = {}){\n\t\tthis.layerID = params.layerID;\n\t\tthis.parentNode = params.parentNode || _rootNode;\n\t\tif (this.parentNode !== undefined) // Will be undefined when creating _rootNode\n\t\t\tthis.parentNode.addChild(this);\n\t\tif (params.parentFlags !== undefined)\n\t\t\tthis.parentFlags = params.parentFlags;\n\t\telse\n\t\t\tthis.parentFlags = PARENTFLAG.ALL;\n\t\t\n\t\t/** @type LayerTreeNode[] */\n\t\tthis.children = [];\n\t\t\n\t\tthis._position = params.position || new Vec3(0, 0, 0);\n\t\tthis._positionMatrix = new Mat4();\n\t\tthis._positionChanged = true;\n\n\t\tthis._rotation = params.rotation || new Vec3(0, 0, 0);\n\t\tthis._rotationMatrix = new Mat4();\n\t\tthis._rotationChanged = true;\n\t\t\n\t\tthis._scale = params.scale || new Vec3(1, 1, 1);\n\t\tthis._scaleMatrix = new Mat4();\n\t\tthis._scaleChanged = true;\n\n\t\tthis._localTransform = new Mat4();\n\t\tthis._localTransformChanged = true;\n\t\t\n\t\t_treeDirectory[this.layerID] = this;\n\t}\n\t\n\t/**\n\t * Removes this node from the tree.\n\t */\n\tdestruct() {\n\t\tremoveChildren();\n\t\tthis.parentNode.removeChild(this);\n\t\tdelete _treeDirectory[this.layerID];\n\t\treturn null;\n\t}\n\n\tget layer() { return thisScene.getLayer(this.layerID); }\n\tget name() { return this.layer.name; }\n\n\t/** @return {Vec3} */\n\tget position() { return this._position; }\n\tset position(newPos) {\n\t\tif (newPos instanceof Vec3) {\n\t\t\tthis._position = newPos;\n\t\t\tthis._positionChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newPos;\n\t}\n\tget positionMatrix() {\n\t\tif (this._positionChanged) {\n\t\t\tthis._positionMatrix = Mat4.fromPosition(this._position);\n\t\t\tthis._positionChanged = false;\n\t\t}\n\t\treturn this._positionMatrix;\n\t}\n\n\n\t/** @return {Vec3} */\n\tget rotation() { return this._rotation; }\n\tset rotation(newRot) {\n\t\tif (newRot instanceof Vec3) {\n\t\t\tthis._rotation = newRot;\n\t\t\tthis._rotationChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newRot;\n\t}\n\tget rotationMatrix() {\n\t\tif (this._rotationChanged) {\n\t\t\tthis._rotationMatrix = Mat4.fromEuler(this._rotation, \"XYZ\");\n\t\t\tthis._rotationChanged = false;\n\t\t}\n\t\treturn this._rotationMatrix;\n\t}\n\n\t/** @return {Vec3} */\n\tget scale() { return this._scale; }\n\tset scale(newScale) {\n\t\tif (newScale instanceof Vec3) {\n\t\t\tthis._scale = newScale;\n\t\t\tthis._scaleChanged = true;\n\t\t\tthis._localTransformChanged = true;\n\t\t}\n\t\treturn newScale;\n\t}\n\tget scaleMatrix() {\n\t\tif (this._scaleChanged) {\n\t\t\tthis._scaleMatrix = Mat4.fromScale(this._scale);\n\t\t\tthis._scaleChanged = false;\n\t\t}\n\t\treturn this._scaleMatrix;\n\t}\n\n\t/** The local offset from the paren't axis/origin */\n\tget localTransform() {\n\t\tif (this._localTransformChanged) {\n\t\t\tthis._localTransform = (\n\t\t\t\tthis.positionMatrix.multiply(\n\t\t\t\tthis.rotationMatrix.multiply(\n\t\t\t\tthis.scaleMatrix\n\t\t\t)));\n\t\t\tthis._localTransformChanged = false;\n\t\t}\n\t\treturn this._localTransform;\n\t}\n\n\t/**\n\t * @return {Mat4} The final transformation matrix for this node \n\t */\n\tget worldTransform() {\n\t\tif (!(this.parentFlags & (PARENTFLAG.POSITION | PARENTFLAG.ROTATION | PARENTFLAG.SCALE)))\n\t\t\treturn this.localTransform;\n\n\t\tlet parentTransform = undefined;\n\t\tif ((this.parentFlags & PARENTFLAG.POSITION) && (this.parentFlags & PARENTFLAG.ROTATION) && (this.parentFlags & PARENTFLAG.SCALE)) {\n\t\t\tparentTransform = this._parentTransform || new Mat4();\n\t\t}\n\t\telse {\n\t\t\tparentTransform = new Mat4();\n\t\t\tif (this.parentFlags & PARENTFLAG.POSITION)\n\t\t\t\tparentTransform.multiply(this.parentNode.positionMatrix);\n\t\t\tif (this.parentFlags & PARENTFLAG.ROTATION)\n\t\t\t\tparentTransform.multiply(this.parentNode.rotationMatrix);\n\t\t\tif (this.parentFlags & PARENTFLAG.SCALE)\n\t\t\t\tparentTransform.multiply(this.parentNode.scaleMatrix);\n\t\t}\n\t\treturn parentTransform.multiply(this.localTransform);\n\t}\n\n\t/**\n\t * @param [parentTransform] {Mat4} - The parent's final transformation matrix\n\t */\n\tupdate(parentTransform) {\n\t\tthis._inheritExternalChanges();\n\n\t\tthis._parentTransform = parentTransform\n\t\tlet finalTransform = this.worldTransform;\n\n\t\tif (this !== _rootNode) {\n\t\t\tif (!this.layer) {\n\t\t\t\t// This node's layer no longer exists, so remove this node from the tree.\n\t\t\t\treturn this.destruct();\n\t\t\t}\n\n\t\t\tthis._lastOrigin = this.layer.origin = finalTransform.toPosition();\n\t\t\tthis._lastAngles = this.layer.angles = finalTransform.toEuler(\"XYZ\");\n\t\t\tthis._lastScale = this.layer.scale = finalTransform.toScale();\n\t\t\tif (this.parentFlags & PARENTFLAG.VISIBILITY)\n\t\t\t\tthis.layer.visible = this.parentNode.layer.visible;\n\t\t}\n\n\t\t// update our children\n\t\tfor (const child of this.children) {\n\t\t\tchild.update(finalTransform);\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether any external source(s) altered properties of the layer since our last update, and updates the node state accordingly.\n\t */\n\t_inheritExternalChanges() {\n\t\tif (this !== _rootNode) {\n\t\t\tlet parentLayer = this.parentNode.layer;\n\t\t\tif (this._lastOrigin !== undefined && !OMGVector.equal(this.layer.origin, this._lastOrigin))\n\t\t\t\tthis.position = this.layer.origin.subtract(parentLayer.origin).divide(parentLayer.scale);\n\t\t\tif (this._lastAngles !== undefined && !OMGVector.equal(this.layer.angles, this._lastAngles))\n\t\t\t\tthis.rotation = this.layer.angles.subtract(parentLayer.angles);\n\t\t\tif (this._lastScale !== undefined && !OMGVector.equal(this.layer.scale, this._lastScale))\n\t\t\t\tthis.scale = this.layer.scale.divide(parentLayer.scale);\n\t\t}\n\t}\n\n\t/** \n\t * Sets the parent of this node.\n\t * @param parentNode {LayerTreeNode} - This node's new parent node.\n\t */\n\tsetParent(parentNode) {\n\t\tif (parentNode === _rootNode && this.children.length === 0)\n\t\t\tthis.destruct();\n\t\telse if (parentNode !== this.parentNode) {\n\t\t\tthis.parentNode.removeChild(this);\n\t\t\tparentNode.addChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Detaches this node from its current parent node.\n\t */\n\tunParent() {\n\t\tthis.parentNode.removeChild(this, false);\n\t}\n\n\taddChild(childNode) {\n\t\tif (childNode instanceof LayerTreeNode)\n\t\tchildNode.parentNode = this;\n\t\tthis.children.push(childNode);\n\t}\n\n\t/** \n\t * Detaches the given child node from this node, and attaches it to this node's parent. \n\t */\n\tremoveChild(childNode, attachtoParent = true) {\n\t\tchildIndex = this.children.indexOf(childNode);\n\t\tif (childIndex !== -1) {\n\t\t\tif (attachtoParent)\n\t\t\t\tchildNode.setParent(this.parentNode);\n\t\t\telse\n\t\t\t\tchildNode.setParent(_rootNode);\n\t\t\tthis.children.splice(childIndex, 1);\n\t\t}\n\t}\n\tremoveChildren() { for(const child of this.children) this.removeChild(child); }\n}\n_rootNode = new LayerTreeNode({layerID: -1, parentFlags: 0});\n\n/**\n * Returns the node for a given layer if it exists, or undefined if no node exists yet.\n * @return {LayerTreeNode}\n */\nfunction getNode(layer) {\n\treturn _treeDirectory[thisScene.getLayerIndex(layer)];\n}\n\nclass LayerParenting {\n\tstatic update(){\n\t\t_rootNode.update();\n\t}\n\n\t/**\n\t * Attaches a child layer to a parent layer, causing it to move and rotate along with the parent.\n\t * @param targetLayer {ILayer} - The child layer.\n\t * @param parentLayer {ILayer} - The parent layer.\n\t * @param [parentFlags] {PARENTFLAG} - An optional set of flags enabling or disabling parenting of various layer attributes.\n\t */\n\tstatic setParent(targetLayer, parentLayer, parentFlags = PARENTFLAG.ALL) {\n\t\tif (!targetLayer)\n\t\t\treturn null;\n\t\tif (!parentLayer) {\n\t\t\tunParent(targetLayer);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet targetNode = getNode(targetLayer);\n\t\tlet parentNode = getNode(parentLayer);\n\t\tif (parentNode === undefined)\n\t\t\tparentNode = new LayerTreeNode({\n\t\t\t\tlayerID: thisScene.getLayerIndex(parentLayer),\n\t\t\t\tposition: parentLayer.origin,\n\t\t\t\trotation: parentLayer.angles,\n\t\t\t\tscale: parentLayer.scale\n\t\t\t\t})\n\t\tif (targetNode === undefined) {\n\t\t\tnew LayerTreeNode({\n\t\t\t\tlayerID: thisScene.getLayerIndex(targetLayer), \n\t\t\t\tparentNode: parentNode, \n\t\t\t\tparentFlags: parentFlags, \n\t\t\t\tposition: targetLayer.origin.subtract(parentLayer.origin).divide(parentLayer.scale),\n\t\t\t\trotation: targetLayer.angles.subtract(parentLayer.angles),\n\t\t\t\tscale: targetLayer.scale.divide(parentLayer.scale)\n\t\t\t\t})\n\t\t}\n\t\telse if (targetNode.parentNode === parentNode) {\n\t\t\ttargetNode.parentFlags = parentFlags;\n\t\t\treturn parentLayer;\n\t\t}\n\t\telse {\n\t\t\ttargetNode.setParent(parentNode)\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns the node for a given layer if it exists, or undefined if no node exists yet.\n\t * @return {LayerTreeNode}\n\t */\n\tstatic getNode(layer) { return getNode(layer); }\n\n\t/** Detaches the given layer from its parent. Does not detach any children from the given layer. */\n\tstatic unParent(childLayer) {\n\t\tlet node = getNode(childLayer)\n\t\tif (node)\n\t\t\tnode.unParent();\n\t}\n}\nshared.LayerParenting = LayerParenting;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 12,
			"image" : "models/util/solidlayer.json",
			"ledsource" : false,
			"locktransforms" : true,
			"name" : "Interpolators (shared script module)",
			"origin" : "-5.50000 0.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\n/** @type {Interpolator[]} */\nlet activeInterps = [];\n\n\nexport function update() {\n\tactiveInterps.forEach((interp, index, array) => {\n\t\tinterp.update(engine.frametime + (shared.timeNudge || 0));\n\t});\n\tshared.timeNudge = 0;\n}\n\n\n\n\n/** Modifies an object property over a period of time */\nclass Interpolator {\n/** \n * @typedef {Object} InterpolatorParams\n * @property targetObject {object} - The object whose property value will be modified\n * @property propertyName {String} - The name of the property key to be modified\n * @property duration {Number} - How long it will take to reach the final value.\n * @property startValue {object} - An optional starting value. If not set, will use the properties existing value.\n * @property startOffset {object} - An optional offset to the starting value.\n * @property endValue {object} - The value the target variable will reach at the end of the duration. If not set, will use the properties existing value.\n * @property endOffset {object} - An optional offset to the end value.\n */\n\t/** \n\t * @param {InterpolatorParams} params - Object which allows parameters to be set by name. \n\t */\n\tconstructor(params) {\n\t\tthis.targetObject = params.targetObject;\n\t\tthis.propertyName = params.propertyName || \"origin\";\n\t\tthis.duration = params.duration || 1.0;\n\t\tthis.elapsedTime = 0;\n\t\tactiveInterps.push(this);\n\t\t\n\t\tif (params.startValue !== undefined)\n\t\t\tthis.startValue = Helpers.add(params.startValue, params.startOffset);\n\t\telse\n\t\t\tthis.startValue = Helpers.add(this.targetValue, params.startOffset);\n\t\tthis.targetValue = this.startValue;\n\t\t\n\t\tif (params.endValue !== undefined)\n\t\t\tthis.endValue = Helpers.add(params.endValue, params.endOffset);\n\t\telse\n\t\t\tthis.endValue = Helpers.add(this.targetValue, params.endOffset);\n\t}\n\n\t/** \n\t * Returns an array of interpolators currently affecting the given object \n\t */\n\tstatic getInterpolators(targetObject) {\n\t\tlet targetInterps = [];\n\t\tfor (let i of activeInterps) {\n\t\t\tif (i.targetObject === targetObject)\n\t\t\t\ttargetInterps.push(i);\n\t\t}\n\t}\n\n\t/**\n\t * Instantly destroys alls interpolators affecting the target object\n\t */\n\tstatic clearInterpolators(targetObject) {\n\t\tconsole.log(\"HI\");\n\t\tlet interps = Interpolator.getInterpolators(targetObject) || [];\n\t\tfor (let i of interps)\n\t\t\ti.destroy();\n\t}\n\n\tstatic finishInterpolators(targetObject) {\n\t\tlet interps = Interpolator.getInterpolators(targetObject) || [];\n\t\tfor (let i of interps) { \n\t\t\ti.finish();\n\t\t\ti.destroy();\n\t\t}\n\t}\n\n\tget targetValue() {return this.targetObject[this.propertyName]}\n\tset targetValue(newValue) {return this.targetObject[this.propertyName] = newValue}\n\n\tupdate(dt) {\n\t\tthis.elapsedTime += dt;\n\t\tif (this.elapsedTime > this.duration) {\n\t\t\tthis.finish();\n\t\t\tthis.destroy();\n\t\t}\n\t\telse\n\t\t\tthis.interpolate();\n\t}\n\n\tinterpolate() {\n\t\t// Perform interpolation here\n\t}\n\n\t/** Performs any final adjustments before this interpolator expires. */ \n\tfinish() {\n\t\tthis.targetValue = this.endValue;\n\t}\n\n\tdestroy() {\n\t\tactiveInterps.splice(activeInterps.indexOf(this), 1);\n\t}\n}\nshared.Interpolator = new Object();\nshared.Interpolator.getInterpolators = Interpolator.getInterpolators;\nshared.Interpolator.clearInterpolators = Interpolator.clearInterpolators;\nshared.Interpolator.finishInterpolators = Interpolator.finishInterpolators;\n\n\n/** Transitions from the start to end value at a constant rate. */\nclass LinearInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, percentage);\n\t}\n}\nshared.LinearInterp = LinearInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseOutInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, percentage * (2 - percentage));\n\t}\n}\nshared.EaseOutInterp = EaseOutInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseOutStrongInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, Math.pow(percentage-1, 3) + 1);\n\t}\n}\nshared.EaseOutStrongInterp = EaseOutStrongInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first then speeding up. */\nclass EaseInInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet percentage = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, Math.pow(percentage, 2));\n\t}\n}\nshared.EaseInInterp = EaseInInterp;\n\n\n\n/** Transitions from the start to end value, moving slowly at first, quickly in the middle, then slow again at the end. */\nclass EaseInOutInterp extends Interpolator {\n\tinterpolate() {\n\t\tlet x = this.elapsedTime / this.duration;\n\t\tthis.targetValue = Helpers.lerp(this.startValue, this.endValue, x * x * (3 - 2 * x));\n\t}\n}\nshared.EaseInOutInterp = EaseInOutInterp;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : 
			{
				"animation" : 
				{
					"c0" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 8,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 20,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 29,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c1" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 8,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 20,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 29,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c2" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 8,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -0.00263
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 20,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0.0020899999999999998
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 29,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"options" : 
					{
						"fps" : 2.8999999999999999,
						"length" : 29,
						"mode" : "mirror"
					},
					"relative" : true
				},
				"value" : "0.00000 0.00000 0.00000"
			},
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/pulse/effect.json",
					"id" : 364,
					"name" : "Eye glow",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 7
							},
							"constantshadervalues" : 
							{
								"amount" : 0.40000000000000002,
								"bounds" : "0 1",
								"noiseamount" : 0.29999999999999999,
								"noisespeed" : 0.040000000000000001,
								"power" : 1,
								"speed" : 1,
								"tinthigh" : "1 0.08627450980392157 0",
								"tintlow" : "1 1 1"
							},
							"id" : 365,
							"textures" : 
							[
								null,
								"util/noise",
								"masks/pulse_mask_ee0d9bbc6d0516b8583c8fb3e841485c0b7ec4e8"
							]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/pulse/effect.json",
					"id" : 54,
					"name" : "",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 4
							},
							"constantshadervalues" : 
							{
								"amount" : 0.050000000000000003,
								"bounds" : "0.00000 1.00000",
								"noiseamount" : 0.050000000000000003,
								"tinthigh" : "0.28627450980392155 0 0",
								"tintlow" : "1 1 1"
							},
							"id" : 55,
							"textures" : [ null, "util/noise" ]
						}
					],
					"visible" : false
				},
				{
					"file" : "effects/workshop/2243518505/depth_map/effect.json",
					"id" : 1469,
					"name" : "Head turning (Cursor Position)",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"1. strength/ distance" : 0.40000000000000002,
								"2. midlevel" : 0.25,
								"3. normalize to center" : 1,
								"4. invert depth map" : 0
							},
							"id" : 1470,
							"textures" : [ null, "Face Depth" ]
						}
					],
					"visible" : false
				},
				{
					"file" : "effects/depth_map_custom/effect.json",
					"id" : 218,
					"name" : "Head Turning (Random Positions)",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"1. strength/ distance" : 0.5,
								"2. midlevel" : 0.25,
								"3. normalize to center" : 1.0,
								"4. invert depth map" : 0,
								"5. Focal point" : 
								{
									"script" : "'use strict';\n\n/** Number of seconds to wait before glancing somewhere else. */\nconst MINGLANCEDELAY = 1;\nconst MAXGLANCEDELAY = 4;\n/** How quickly the eyes should turn towards the target position. */\nconst MINGLANCETURNSPEED = .4;\nconst MAXGLANCETURNSPEED = .6;\n\n/** Draws a sprite at the target glance position. */\nconst DEBUG = false;\n\n\n/** How much time is left before selecting a new glance target. */\nlet nextGlanceDelay = MINGLANCEDELAY + Math.random() * (MAXGLANCEDELAY - MINGLANCEDELAY);\n/** How quickly to turn towards the target position. */\nlet turnSpeed = MINGLANCETURNSPEED + Math.random() * (MAXGLANCETURNSPEED - MINGLANCETURNSPEED);\n/** The screen position that the eyes are turning towards. (0,0) represents the top left corner. */\nlet glanceTarget = new Vec2(0.5, 0.5);\n\n/**\n * @param {Vec2} value - for property '5. Focal point'\n * @return {Vec2} - update current property value\n */\nexport function update(value) {\n\tnextGlanceDelay -= engine.frametime;\n\tif (nextGlanceDelay <= 0) {\n\t\tnextGlanceDelay += MINGLANCEDELAY + Math.random() * (MAXGLANCEDELAY - MINGLANCEDELAY);\n\t\tturnSpeed = MINGLANCETURNSPEED + Math.random() * (MAXGLANCETURNSPEED - MINGLANCETURNSPEED);\n\t\tglanceTarget = new Vec2(Math.random(), Math.random());\n\t}\n\n\tlet vecToTarget = glanceTarget.subtract(value);\n\tlet distToTarget = magnitude(vecToTarget);\n\t\t\n\tlet oldPosition = value;\n\tlet newPosition = undefined;\n\n\tif (distToTarget > 0.00001) {\n\t\tlet movement = distToTarget * turnSpeed * engine.frametime;\n\t\tmovement = Math.min(movement, distToTarget); // Don't move past the target\n\n\t\tnewPosition = oldPosition.add(vecToTarget.normalize().multiply(movement));\n\t}\n\telse\n\t\tnewPosition = glanceTarget;\n\t\n\n\tif (DEBUG) {\n\t\t// console.log(`glance target: ${glanceTarget}\\nOld position: ${value}\\nNew position: ${newPosition}\\nVector to Target: ${vecToTarget}\\nDistance: ${distToTarget}`);\n\n\t\tlet debugSprite = thisScene.getLayer(\"_GLANCEDEBUG\");\n\t\tif (!debugSprite) {\n\t\t\tdebugSprite = thisScene.createLayer({\n\t\t\t\tname:\"_GLANCEDEBUG\",\n\t\t\t\timage:\"models/util/solidlayer.json\",\n\t\t\t\tsize:\"32 32\",\n\t\t\t\talignment:\"center\"})\n\t\t}\n\n\t\tdebugSprite.origin = new Vec3(engine.canvasSize.multiply(new Vec2(glanceTarget.x, 1 - glanceTarget.y)));\n\t\tconsole.log(debugSprite.origin);\n\t}\n\n\treturn newPosition;\n}\n\n\n\nfunction magnitude(vec) {\n\treturn (vec.x * vec.x + vec.y * vec.y);\n}",
									"value" : "0.50000 0.50000"
								}
							},
							"id" : 219,
							"textures" : [ null, "Face Depth" ]
						}
					],
					"visible" : true
				}
			],
			"id" : 13,
			"image" : "models/Face.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Face",
			"origin" : 
			{
				"animation" : 
				{
					"c0" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 10,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 15,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 20,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 4.5766599999999471
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 29,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c1" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 10,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -10.147089999999992
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 15,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -12.735470000000021
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 20,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -9.690339999999992
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 29,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c2" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 10,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 15,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 20,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 29,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"options" : 
					{
						"children" : [],
						"fps" : 3.625,
						"length" : 29,
						"mode" : "loop"
					},
					"relative" : true
				},
				"value" : "1920.00000 512.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "4096.00000 4096.00000",
			"solid" : true,
			"visible" : true
		},
		{
			"angles" : "0.00000 0.00000 0.00000",
			"id" : 1522,
			"instanceoverride" : 
			{
				"alpha" : 0.60000002384185791,
				"controlpoint1" : "-282.84644 71.54919 0.00000",
				"controlpoint2" : "263.03760 72.45874 0.00000",
				"count" : 0.40000000596046448,
				"id" : 1524,
				"lifetime" : 1.3999999761581421,
				"speed" : 1.2000000476837158
			},
			"locktransforms" : false,
			"name" : "Eye particles",
			"origin" : "1920.00000 1195.74536 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"particle" : "particles/eye_particles.json",
			"scale" : "1.00000 1.00000 1.00000",
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : "0.00000 0.00000 0.00000",
			"animationlayers" : 
			[
				{
					"additive" : false,
					"animation" : 198,
					"blend" : 1.0,
					"id" : 160,
					"name" : "Hood sway right",
					"rate" : 1.0,
					"visible" : true
				},
				{
					"additive" : false,
					"animation" : 165,
					"blend" : 1.0,
					"id" : 175,
					"name" : "Hood sway left",
					"rate" : 1.1299999952316284,
					"visible" : true
				}
			],
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/pulse/effect.json",
					"id" : 64,
					"name" : "Red tint",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 28
							},
							"constantshadervalues" : 
							{
								"amount" : 0,
								"bounds" : "0.00000 1.00000",
								"noiseamount" : 0.5,
								"tinthigh" : "0.9647058823529412 0.4745098039215686 0.4745098039215686"
							},
							"id" : 65,
							"textures" : [ null, "util/noise" ]
						}
					],
					"visible" : false
				}
			],
			"id" : 158,
			"image" : "models/Hood.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Hood",
			"origin" : 
			{
				"animation" : 
				{
					"c0" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1.2489197384927948,
								"y" : -0.0
							},
							"frame" : 6,
							"front" : 
							{
								"enabled" : true,
								"x" : 1.2489197384927948,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 11,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 12.206300000000056
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 24,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 1.3039599999999609
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -0.96888503268840054,
								"y" : -4.3431602247191012
							},
							"frame" : 36,
							"front" : 
							{
								"enabled" : true,
								"x" : 0.96888503268840054,
								"y" : 4.3431602247191012
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 41,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -12.205809999999929
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 50,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 59,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c1" : 
					[
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 10,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -9.7311399999999821
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 11,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -1.4970744943820478
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 12,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -9.7311399999999821
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 24,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -3.2488399999999729
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 30,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 40,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -9.7311399999999821
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 41,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -1.4970744943820478
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 42,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -9.7311399999999821
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 50,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : -1,
								"y" : 0
							},
							"frame" : 59,
							"front" : 
							{
								"enabled" : false,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c2" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 24,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 50,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"options" : 
					{
						"fps" : 19.666666666666668,
						"length" : 59,
						"mode" : "loop",
						"name" : "Footsteps"
					},
					"relative" : true
				},
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addCheckbox({\n\t\tname: 'footsteps',\n\t\tlabel: 'Footsteps',\n\t\tvalue: false\n\t})\n\t.finish();\n\n/**\n * @param {Vec3} value - for property 'origin'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\tif (scriptProperties.footsteps === true)\n\t\tthisLayer.getAnimation().play();\n\tif (scriptProperties.footsteps === false)\n\t\tthisLayer.getAnimation().stop();\n\treturn value;\n}",
				"scriptproperties" : 
				{
					"footsteps" : 
					{
						"user" : "footsteps",
						"value" : true
					}
				},
				"value" : "1920.00000 512.00000 0.00000"
			},
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"scale" : "1.00000 1.00000 1.00000",
			"size" : "4096.00000 4096.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\n// Enables play/pause in editor",
				"value" : true
			}
		},
		{
			"angles" : "0.00000 0.00000 0.00000",
			"id" : 81,
			"instanceoverride" : null,
			"locktransforms" : false,
			"name" : "Falling dust",
			"origin" : "1920.00000 1200.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"particle" : "particles/falling_dust.json",
			"scale" : "1.00000 1.00000 1.00000",
			"visible" : true
		},
		{
			"angles" : "0.00000 0.00000 0.00000",
			"id" : 168,
			"instanceoverride" : null,
			"locktransforms" : false,
			"name" : "Falling embers",
			"origin" : "1920.00000 1200.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"particle" : "particles/falling_embers.json",
			"scale" : "1.00000 1.00000 1.00000",
			"visible" : true
		},
		{
			"angles" : "0.00000 0.00000 0.00000",
			"id" : 180,
			"instanceoverride" : null,
			"locktransforms" : false,
			"name" : "Falling embers bokeh",
			"origin" : "1920.00000 1200.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"particle" : "particles/Falling_embers_bokeh.json",
			"scale" : "1.00000 1.00000 1.00000",
			"visible" : true
		},
		{
			"angles" : "0.00000 0.00000 0.00000",
			"id" : 1124,
			"instanceoverride" : 
			{
				"controlpoint1" : "-128.00000 451.39398 0.00000",
				"controlpoint2" : "128.00000 451.39392 0.00000",
				"controlpoint3" : "0.00000 750.00000 0.00000",
				"id" : 1125
			},
			"locktransforms" : false,
			"name" : "Rising embers",
			"origin" : "1920.00000 -128.00000 0.00000",
			"parallaxDepth" : "1.00000 1.00000",
			"particle" : "particles/rising_embers.json",
			"scale" : "1.00000 1.00000 1.00000",
			"visible" : true
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/filmgrain/effect.json",
					"id" : 60,
					"name" : "",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 1
							},
							"constantshadervalues" : 
							{
								"exponent" : 1,
								"scale" : 20,
								"strength" : 0.10000000000000001
							},
							"id" : 61,
							"textures" : [ null, "util/noise" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/pulse/effect.json",
					"id" : 69,
					"name" : "Pulsing red tint",
					"passes" : 
					[
						{
							"combos" : 
							{
								"BLENDMODE" : 28
							},
							"constantshadervalues" : 
							{
								"amount" : 0.125,
								"bounds" : "0 1",
								"noiseamount" : 0.25,
								"noisespeed" : 0.040000000000000001,
								"speed" : 0.75,
								"tinthigh" : "0.9647058823529412 0.4745098039215686 0.4745098039215686"
							},
							"id" : 0,
							"textures" : [ null, "util/noise" ]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/waterripple/effect.json",
					"id" : 438,
					"name" : "Heat Waves",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"animationspeed" : 0.25,
								"ratio" : 1.0,
								"ripplestrength" : 0.14999999999999999,
								"scale" : 1,
								"scrolldirection" : 0.0,
								"scrollspeed" : 0.59999999999999998
							},
							"id" : 439,
							"textures" : 
							[
								null,
								"masks/waterripple_mask_e7c24e12109c16ce074e92e388ea2d48c1301419",
								"effects/waterripplenormal"
							]
						}
					],
					"visible" : true
				},
				{
					"file" : "effects/fire/effect.json",
					"id" : 2193,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"alpha" : 0.074999999999999997,
								"colorend" : "1 0 0",
								"colorstart" : "0.3686274509803922 0.08235294117647059 0",
								"distortion" : 0.10000000000000001,
								"feather" : 0.5,
								"scale" : 4,
								"smoothness" : 0,
								"speed" : 1,
								"threshold" : 0
							},
							"id" : 2194,
							"textures" : 
							[
								null,
								"masks/fire_mask_74284a24fe87b5f53e640d5808ef7ab7759a5d2b",
								"util/clouds_256"
							]
						}
					],
					"visible" : true
				}
			],
			"id" : 57,
			"image" : "models/util/fullscreenlayer.json",
			"ledsource" : false,
			"locktransforms" : false,
			"name" : "Post processing",
			"parallaxDepth" : "1.00000 1.00000",
			"perspective" : false,
			"solid" : true,
			"visible" : true
		}
	],
	"version" : 1
}